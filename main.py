# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colaboratory.
"""

import os

import torch
import torch.nn as nn
import torchvision
from PIL import Image
from torch.utils.data import DataLoader
from torchvision import models, transforms
import matplotlib.pyplot as plt

os.chdir('/content/drive/MyDrive/dataset')


class CustomDataset(torch.utils.data.Dataset):
    def __init__(self, path):
        self.data = torchvision.datasets.ImageFolder(root=path)
        self.img_trans = transforms.Compose([transforms.Grayscale(),
                                             transforms.Resize((224, 224)),
                                             transforms.ColorJitter(brightness=0.2,
                                                                    contrast=0.2,
                                                                    saturation=0.2,
                                                                    hue=0.2),
                                             transforms.RandomHorizontalFlip(),
                                             transforms.RandomCrop(224),
                                             transforms.ToTensor(),
                                             transforms.Normalize([0.5], [0.5])])

    def __len__(self):
        return len(self.data.samples)

    def __getitem__(self, idx):
        img = Image.open(self.data.imgs[idx][0])
        img = self.img_trans(img)

        if img.shape[0] < 3:
            img = torch.cat([img] * 3, 0)

        label = torch.tensor(self.data.imgs[idx][1])

        return img, label


batch_size = 4
dataloader = {
    'train': DataLoader(CustomDataset(path='train'), batch_size=batch_size, shuffle=True),
    'valid': DataLoader(CustomDataset(path='valid'), batch_size=batch_size, shuffle=False)
}

device = 'cuda:0' if torch.cuda.is_available() else 'cpu'

model_ft = models.resnet50(pretrained=True)
for param in model_ft.parameters():
    param.requires_grad = True

num_ftrs = model_ft.fc.in_features
model_ft.fc = nn.Linear(num_ftrs, 2)
model_ft = model_ft.to(device)

loss_fn = torch.nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model_ft.parameters(), lr=1e-6)

num_epochs = 200

train_loss = []
valid_loss = []
train_accuracy = []
valid_accuracy = []

for epoch in range(num_epochs):
    print("================")
    print(f"Epoch {epoch}")
    for phase in ['train', 'valid']:
        model_ft.train() if phase == 'train' else model_ft.eval()

        cost = 0
        corrects = 0.0
        sample_size = 0

        for input, label in dataloader[phase]:
            input, label = input.to(device), label.to(device)

            outputs = model_ft(input)
            _, pred = torch.max(outputs, 1)
            loss = loss_fn(outputs, label)
            optimizer.zero_grad()

            if phase == 'train':
                loss.backward()
                optimizer.step()

            cost += loss.item() * input.size(0)
            corrects += torch.sum((pred == label).float())
            sample_size += input.size(0)

        cost_avg = cost / sample_size
        accuracy = corrects / sample_size

        if phase == 'train':
            train_loss.append(cost_avg)
            train_accuracy.append(corrects.cpu().detach())
        else:
            valid_loss.append(cost_avg)
            valid_accuracy.append(corrects.cpu().detach())

        print(phase, "loss: ", cost_avg, "Accuracy: ", accuracy)


def show_plot(train_value, valid_value, train_color, valid_color, train_label, valid_label, ylabel):
    plt.figure(figsize=(10, 7))
    plt.plot(train_value, color=train_color, label=train_label)
    plt.plot(valid_value, color=valid_color, label=valid_label)
    plt.xlabel('Epochs')
    plt.ylabel(ylabel)
    plt.legend()
    plt.show()


show_plot(train_loss, valid_loss, 'orange', 'red', 'train loss', 'validation loss', 'Loss')
show_plot(train_accuracy, valid_accuracy, 'green', 'blue', 'train accuracy', 'validation accuracy', 'Accuracy')
